# 입실 체크 해주세요 !! 🎂

클래스 상속 - extends
인터페이스 상속 - implements

## 복습용 지시 사항
LED / Mouse 클래스에 고유 메서드들을 정의합니다.
LED -> call1() / changeColor() -> 조명 색깔을 변경합니다.
Mouse -> call1() / leftClick() -> 왼쪽 버튼을 클릭합니다.

SmartPhone / Speaker / Tv 클래스를 각각 어제 작성한 방식으로
클래스를 정의하시고
Smartphone -> call1() -> touchScreen() -> 스크린을 터치합니다.
Speaker -> call1() -> changeEqual() -> 이퀄라이저를 변경합니다.
Tv -> call1() -> channelUp() -> 채널을 한 칸 올립니다.

ch16_objects / ObjectTest / ObjectTestMain / 

# Object 클래스
- '모든 클래스는 Object 클래스를 상속 받는다.' 그래서 interface나 다른 상속 관련 수업에서
    '메서드 재정의'(alt+ins)하게 되면 Object 클래스 어쩌고가 나온다는 점을 확인했습니다.

    1. toString() - 기본적으로 모든 클래스는 Object 클래스를 상속 받아, Object의
        toSTring() 메서드를 사용하게 되는데, 클래스 이름과 해시코드(주소지라는 표현으로
        사용)를 반환함. -> 이를 override하고 재정의하여 필드를 표현하는 등 다양한 방식
        으로 사용하는 편.
        - 왜 사용하는가? - 사람들이 읽기 편한 방식으로 재정의하고, '객체명만으로'
            불러오는 것이 가능함. 즉 객체명.toString()형태로 쓰지 않고, 객체명만으로
            메서드를 호출하는 것이 가능(바로 코드로 보여드릴 예정입니다)

    2. equals() - 두 객체가 '논리적으로 같은지'를 비교하는 메서드. 기본적으로 Object의
        equals() 메서드는 두 객체의 참조 주소를 비교합니다.
        
        형식
  
        객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조 주소가 동일한지 확인.
  
        마찬가지로 3형식 문장으로 보시면 됩니다(equals가 3인칭 단수 동사로 쓰였습니다.)

    3. hashCode() - 객체를 정수값(해시값)으로 변환(16진수가 아니라). 해시 값은 주로
        해시 기반 Collections에서 사용됩니다(추후 수업 예정). equals() 메서드를
        override하면 hashCode()도 반드시 override해야만 합니다.

        동일한 객체는 동일한 해시 코드를 가져야하기 때문인데, 이게 문제가 좀 있는게
        해시 코드가 같다고 해서 항상 equals()가 true가 아닐 때도 있습니다.

# Lombok 라이브러리 설치 과정
상단 메뉴바 -> 설정(ctrl + alt + s) -> 플러그인(plugins)
-> lombok 검색 -> 설치 -> 활성화

## 의존성 주입(Dependency Injection)
구글에서 -> mvn 검색
https://mvnrepository.com/
으로 들어가서 lombok 검색 -> project lombok 클릭 -> 맞는 빌드 시스템을 고르셔야 하는데,
저희의 경우에느 Maven이었습니다(저랑 방특 / 웹 수업 하신 분들은 gradle short)
클립보드에서 `<dependency>`어쩌고 복사해옵니다.
Maven 기준 -> pom.xml
```xml
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
```
과 같은 방식으로 붙여넣기
- 주의 사항 : 붙여넣기하는 등의 pom.xml 상에서의 변화가 일어나면 우측 상단에 새로고침 마크가 뜹니다.
    걔 안 눌러주면 절대 반영 안되니까 꼭꼭꼭꼭 눌러주세요.

## 제대로 설치됐는지 검증
UserEntityLombok에서 public class 어쩌고 위에 @Setter 등 했을 때 lombok으로 자동완성되는지 확인

# Lombok
## 정의
Java에서 반복적으로 작성해야하는 코드(boilerplate code)를 자동으로 생성해주는 라이브러리

## 장점
- 코드의 가독성을 높일 수 있다.
  - 주석을 통한 애너테이션(@)을 붙여서 코드 생성을 제어 가능. 특히 스크롤링해서 특정 필드가
    setter / getter가 있는지 하나하나 찾아볼 필요 없이 @Getter가 있으면 Getter가 있는거고
    @ToString이 있으면 toString() 메서드가 있는 식으로 곧장 확인이 가능하기 때문에
    코드 라인의 수는 줄어들면서 동시에 가독성이 향상되는 장점이 있음.

## 종류
1. @Data
   - @Getter / @Setter / @RequiredArgsConstructor / @ToString / @EqualAndHashCode
   애너테이션을 포함하는 종합 패키지
2. @NoArgsConstructor
   - 기본 생성자를 생성
3. @RequiredArgsConstructor
    - final 또는 @NonNull로 지정된 필드를 매개변수로 받는 생성자를 생성
4. @Getter / @Setter
    - 각 필드에 대해 getter / setter 메서드들을 생성
    - 클래스 레벨에 사용하면(public class 위) 모든 필드에 대해, 필드 레벨에 사용하면 특정
        필드에 대해서만 getter / setter가 생성됨 -> 저희는 클래스레벨에만 적용했었습니다.
5. @EqualAndHashCode
    - equals() / hashCode() 메서드를 자동으로 생성 -> 둘이 세트라서 묶여있습니다.
6. @ToString
    - toString() 메서드 자동으로 생성
    - 객체의 필드 값을 문자열로 표현해주는 메서드(객체명만으로 호출 가능)
7. @AllArgsConstructor
    - 모든 필드를 포함하는 매개변수 생성자를 생성
    - @Data에 포함되어있지 않다는 점에 주의하실 필요가 있습니다.

다 하신 분은 ch18_static -> Product / ProductMain 생성

# static

## 정의
- 클래스 수준(인스턴스 수준이 아니라)에서 변수를 정의하거나 메서드를 선언할 때 사용
- static으로 선언된 변수나 메서드는 클래스의 인스턴스에 속하지 않음(즉 객체의 고유값이 아니다).
- 클래스 자체에 속하게 됨.
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 인스턴스 변수, 메서드와 구분됩니다.
  - 저희는 ch08_methods에서 call1() ~ call4()를 정의하고 호출할 때 객체를 생성하지 않았습니다.

## 특징
1. 클래스 수준의 변수 및 메서드 - static 변수와 메서드는 클래스 로드 시 메모리에 할당
   (객체가 생성될 때가 아니라)
2. 공유 - 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나
    상태를 저장할 때 유용합니다.

```java
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class KorItStudent4 extends KorItStudent {
    // static 변수 선언 및 초기화
    private static String staticCurricumlum = "4월 국비";
    // 필드 선언
//    private String curriculum; // 130번 라인이 있다면 불필요.
    private String name;
    private int age;
}

public class KorItStudent4Main {
    public static void main(String[] args) {
        KorItStudent4 student1 = new KorItStudent4("김일", 20);
        KorItStudent4 student2 = new KorItStudent4("김이", 21);
        KorItStudent4 student3 = new KorItStudent4("김삼", 22);
        KorItStudent4 student4 = new KorItStudent4("김사", 23);
    }
}
```
이상의 코드 블럭의 경우 KorItStudent4로 생성되는 객체들은 
private static String staticCurriculum 변수를 가지고 될겁니다. 즉 어느 클래스의
인스턴스인지만 확인하더라도 몇 월 국비생인지를 확인할 수 있게 되겠죠(객체에 일일이 정의할 필요x)

3. 인스턴스가 필요 없음 - 객체를 생성하지 않고도 클래스명.변수 / 클래스명.메서드명()으로
    접근이 가능합니다(저희 위의 예시에서는 static 변수에 private을 썼으니 접근 불가겠죠)

4. 메모리 효율성 - static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당하기 때문에
    객체 생성 시마다 메모리 할당이 빈번하게 일어나는 인스턴스 변수에 비해 효율성이 좋습니다.
   (즉, 공유되는 속성이 있다면 static 변수를 적극적으로 도입하는 것이 효율적이겠죠)





